---
title: "Vibe Coding 的新手體驗 - Claude Code on desktop"
date: 2026-01-06
lastmod: 2026-01-06
description: "分享 Claude Code on Desktop 的 Vibe Coding 初體驗。探討其基於 .claude-worktrees 的隔離運作機制、情緒價值滿點的協作體驗，以及在 Session 管理、Git 操作與 Context 讀取上遇到的實際問題與地雷。"
tags: ["Claude"]
---

# Vibe Coding 的新手體驗 - Claude Code on Desktop

**去年 12 月**在嘗試 Vibe Coding 時，先選擇使用 Claude Code on desktop，就先找一個之前的舊專案來測試。在練習 Vibe Coding 時，因為想了解它們到底能做到什麼程度，所以也沒太特意介入。再加上我只知道 Claude 有 5 小時的重置額度，沒想到還有一個隱藏的 **每週運算時數限制 (Weekly Active Compute Hours)**（Anthropic 在 2025 年 8 月底的通知信中曾指出，Pro 用戶每週約 40-80 小時的 Sonnet 4 運算量）。因為 Vibe Coding 消耗 Token 的速度遠超預期，結果我不僅提前把額度用完了，甚至還因為每週額度的計算是「7 天滾動式」的，直接被鎖了好幾天無法使用。加上後續轉為評估 GitHub Copilot 而暫時未續訂，因此這段測試實際上並未完成。

由於目前暫時無法進入系統操作截圖，本篇僅能以文字記錄這段體驗。

## 什麼是 Claude Code on Desktop？

Claude Desktop 在 **2025 年 11 月 25 日** 的更新中加入了 **Code** 頁籤，這是一個可以直接在桌面應用程式中運行 Claude Code 的介面。使用者不需要開啟終端機，只需點擊頁籤並安裝相依元件，即可開始使用。

### 運作機制

實際操作後，我發現它的隔離邏輯相當特別。當選擇一個 Repository 後，它並不會直接修改原始檔案，而是會在使用者資料夾下的 `.claude-worktrees` 目錄中，建立一個與專案同名的資料夾。接著，它會在該目錄下產生一個 **隨機名稱的子資料夾**（包含專案完整副本），並在裡面建立一個隨機名稱的 Git Branch。

所有的修改都會發生在這個隔離的環境與分支上，這種設計確保了原始專案的安全，也實現了多個任務並行處理的可能性（每個 Session 對應不同的隔離環境）。

## 實際體驗

### 上下文理解的巨大差異

早期使用 AI 輔助（如 ChatGPT）時，往往受限於 UI 介面的輸入上限。雖然後來支援了長文甚至檔案上傳，但這與 Vibe Coding **直接讀取整個專案**所能獲取的上下文相比，精準度仍有巨大差異。

以往我常因為懶得寫程式，會先把邏輯和預期步驟寫給 Claude，請它產出程式碼後再進行調整。但常遇到輸出長度限制導致程式碼被截斷，請它「繼續生成」時，接續的程式碼有時會接不上（這在早期 ChatGPT 特別嚴重）。而當我要寫的範圍邏輯過大時，很容易因為多次產出的程式碼細節無法銜接，需要花費很多時間進行整理。

而在 Vibe Coding 的模式下，AI 能完整理解專案結構，產出的程式碼也不再有截斷問題，這是我認為與傳統對話式 AI 最大的差異體驗。

### 滿滿的情緒價值

不得不說，Vibe Coding 用起來滿爽。它像是一個情緒穩定的資深同事，可以進行討論，又可以幫忙處理一些比較繁雜的工作。當我請它優化程式碼時，它不僅會乖乖照做，還會給出詳細的解釋。有的時候我浪費額度，多嘴問了一句「我會不會要求太多？」，它也回覆說：「**這才是良好的工程師品質**」。給予滿滿的情緒價值。

## 遇到的問題與地雷

### 1. 對話工作階段 (Session) 無法延續

這是我遇到最嚴重的問題。當太久沒操作時，輸入訊息會出現 **401 Unauthorized** 錯誤，導致一旦連線中斷，舊的 Session 就再也回不去了。更慘的是，若開啟新 Session，它會強制在 `.claude-worktrees` 建立一個**全新**的隨機隔離環境。這導致我無法接續原本的工作進度，一切 Context 歸零，這是我覺得最困擾的點。

::: tip
針對這個問題，我後來測出了一個非正規解法，詳見：[解決 Claude Code on desktop 無法恢復對話工作階段的問題](./%E8%A7%A3%E6%B1%BA%2520Claude%2520Code%2520on%2520desktop%2520%E7%84%A1%E6%B3%95%E6%81%A2%E5%BE%A9%E5%B0%8D%E8%A9%B1%E5%B7%A5%E4%BD%9C%E9%9A%8E%E6%AE%B5%E7%9A%84%E5%95%8F%E9%A1%8C.md)
:::

### 2. 上下文理解的邏輯矛盾

我對於 Commit Message 和 Coding Style 有自己的偏好，因此撰寫了相關文檔請它閱讀，但過程並不順利。

首先，當 Session 中斷重連後，它往往會直接忘記之前的設定。我也曾詢問是否需要在 `CLAUDE.md` 設定引用其他 Markdown 檔案，它原本自信地告訴我「**不需要，載入時我會閱讀所有 Markdown 檔案**」。但實測發現它根本沒讀，當我質疑它時，它又改口說「載入時我只會讀 `CLAUDE.md`，但在寫 Commit 時才讀取 Commit 規範檔案」。

但不論它的機制到底是「載入時讀取」還是「寫 Commit 時會讀取」，既然它最終產出的 Commit 都不符合規範，代表這兩種說法在當時當下都是幻覺。最後我還是只能乖乖在 `CLAUDE.md` 中明確寫入規範，它才終於聽話。

關於規範檔案的放置位置，這也引發了另一個思考。我原本傾向將規範「模組化」管理——也就是將規則檔放在專案的特定目錄下，再於 `CLAUDE.md` 中透過連結引用，以保持設定檔簡潔，避免與 `README.md` 重疊，也避免每個專案各自寫各的規範，造成不一致的問題。

但後來與 Gemini 討論得知，這類 AI 編輯器（如 GitHub Copilot）通常只會預設讀取特定的配置檔案（如 `CLAUDE.md` 或 `.github/copilot-instructions.md`）。這裡面的「連結」對 AI 來說只是純文字路徑，並不會自動讀取該檔案的內容進入上下文 (Context)。

~~因此，策略必須調整。雖然建立「中央規範庫」作為唯一的真理來源仍有必要，但應用方式從「引用檔案」轉變為「直接寫入」：開啟新專案時，我從中央庫挑選合適的模組（如 Git 規範、Vue 規範），直接將內容「複製貼上」進 `CLAUDE.md` 本體。這樣雖犧牲了簡潔度，但能確保 AI 100% 讀取到規範，同時維持跨專案的一致性。~~

#### CLAUDE.md 配置最佳實務

根據 [Determine memory type](https://code.claude.com/docs/en/memory#determine-memory-type) 的說明，建議採用分層方式管理上下文：

* **全域設定 (Global)**：`~/.claude/CLAUDE.md`，電腦全部的 Session 都會讀到這設定。
* **專案設定 (Project)**：專案根目錄下的 `CLAUDE.md` 或 `.claude/CLAUDE.md`（推薦）。這是專案專用的主要設定，建議統一收納在 `.claude` 資料夾中以保持根目錄整潔。
* **模組化規則 (Modular Rules)**：`.claude/rules/*.md`。前述提到的「模組化」管理方式，將不同規範拆分（如 `git.md`, `vue.md`），讓 Claude 依據需求讀取。
* **本地覆寫 (Local Override)**：`./CLAUDE.local.md`。專案專用的本地規則，務必搭配 `.gitignore` 避免不小心提交。

另外根據 [Claude Code: Best practices for agentic coding](https://www.anthropic.com/engineering/claude-code-best-practices) 的說明，我們可以在特定子目錄定義該目錄專屬的規則（例如 `backend/CLAUDE.md`）。Claude Code 具備智慧讀取機制，當 Agent 涉及到該目錄下的檔案時，便會自動讀取並套用這些局部上下文，實現更精準的規範控制。

### 3. 幻覺與錯誤資訊

除了上述的文件讀取機制外，它在提供建議時也會出現幻覺。
例如，我詢問規範檔案該放哪裡時，它建議我放在 `.github` 資料夾中。但眾所皆知，`.github` 通常是用來放 GitHub Actions 或 Issue Templates 的，並非業界通用的文檔放置處。這顯示在依賴 AI 建議時，開發者仍需具備判斷能力。

### 4. Git 操作的笨拙與衝突

Claude Code 在執行 Git 操作時，有時會顯得「自作聰明」：

- **繞遠路與越幫越忙**：原本可以用 `git rebase -i` 簡單解決的任務，它可能會繞遠路用其他方式處理。當操作結果不如預期時，它會自動還原並嘗試其他方法，雖然精神可嘉，但這機制並非每次都能成功，有時反而把 Git 線圖搞得更亂。
- **快照機制的雷**：這是所有 AI 編輯器的通病。它會對檔案進行快照，如果你在它操作失敗後**手動介入修改**（例如手動解 Git 衝突），它可能會忽略你的異動，直接用它的舊快照覆蓋回去。

::: warning
若要請它操作 Git，最好直接提供 **Commit Hash**，而不是模糊地描述「修改那個 Commit」，這樣比較安全。
:::

### 5. 效能延遲 (Lag)

在 Desktop 版本操作時，介面會有明顯的延遲。有時因為沒反應，我不小心多按了幾次 Enter，結果它實際上發送了多條訊息。由於每次傳送訊息，它都會輸出大量訊息，很容易沒注意到這件事。這不僅造成操作混亂，還可能導致額度被重複消耗。

## 結語

雖然因為額度問題導致體驗被迫中止，且 Git 操作和 Session 管理上還有很多改進空間，但這次體驗確實讓我看到了開發模式轉變的契機。

AI 工具發展極快，早期 Vibe Coding 還只是一個模糊的概念，一個不注意，現在已經逐漸成熟了。當然，我並不認為所有工作都適合交給 Claude Code。雖然現階段我認為 Claude 仍是最適合寫程式的模型，但每種工具都有其最適用的場景，未來的開發模式應該是「多模型協作 (Multi-Model)」。

舉例來說，如果將場景套用到 Claude Code，或許會是這樣分工：

* **Commit Message**：交給其他免費或便宜的 AI 處理就好，別浪費 Claude 的額度。
* **複雜 Git 操作 (Rebase)**：為了避免修壞線圖，這種比較危險的操作，我覺得還是自己手動來比較安心。
* **Claude Code**：那些需要**深度理解專案**的討論或是開發任務。
* **Gemini / 其他模型**：如果只是問一般的技術問題，或是不涉及大量專案上下文的話，我會改問 Gemini，但別問 Claude，如果使用 Pro 訂閱，Claude Chat 和 Claude Code 是共用額度。

不過該如何根據每個模型的擅長點與費用（Q.Q），找出最適合自己的 AI 工具組合，我還需要花時間繼續摸索。

---

## 異動歷程

- 2026-01-06 初版文件建立。
- 2026-01-07 補充公佈的官方 CLAUDE.md 配置最佳實務與上下文繼承機制說明。
